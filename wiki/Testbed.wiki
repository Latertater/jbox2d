#summary Easily experiment with jbox2d in a friendly environment.
#labels Phase-Implementation

<wiki:toc max_depth="2" />

= Introduction =

So getting physics right can be tough, and bugs with physics can often take a while to discover.  So it's always a good idea to create a physics prototype of the behavior you want before you build your application or game around it.  The testbed is the perfect place to to this, as it provides:
 * run loop
 * simple graphics
 * expandable settings
 * easy input support
 * serialization (saving/loading)
so you can get down to the hairy details of getting your physics correct instead of worrying about other things going wrong.

*PLEASE NOTE:* The testbed api is provided for easy prototyping and testing.  It is not intended for commercial use and might be subject to changes in the future.

= Testbed UI =

Lets start by taking a look at testbed user interface.

[http://jbox2d.googlecode.com/svn/wiki/TestbedAnnotated.png]

|| *UI Element* || *Description* ||
|| Test Selection ||This list contains the tests (and categories) in the testbed.  Clicking on one of these will exit the current test and enter the selected one.  Clicking on a category will start the first test in that category. ||
|| Engine Options || This panel contains options that modifies the way the engine behaves internally. ||
|| Testbed Options || These are options to modify the way the testbed or current test behaves. ||
|| Controls || These buttons are pretty self-explanatory, and save/load are only enabled if the test support serialization. ||
|| Reporting Area ||  This area is for any text from the testbed or test. ||

== Mouse Controls ==

|| Right click drag || moves the viewport around ||
|| Mouse wheel || zooms on the mouse cursor ||
|| Left click || drags around physics objects in the scene (if mouse was over one) ||

== Keyboard Controls ==

|| *R* || restarts the current test ||
|| *[* || goes the last test ||
|| *]* || goes to the next test ||
|| *Space* || launches a 'bomb' in the test ||

= Adding Tests/Settings =

Before we start writing tests, let's learn how to add them to the testbed.  The testbed has a `TestbedModel` where it stores all of the tests and settings.  Here is an example of adding our own category, test, and setting to the testbed.

{{{
TestbedModel model = new TestbedModel();         // create our model

// add tests
TestList.populateModel(model);                   // populate the provided testbed tests
model.addCategory("My Super Tests");             // add a category
model.addTest(new MySuperTest());                // add our test

// add our custom setting "My Range Setting", with a default value of 10, between 0 and 20
model.getSettings().addSetting(new TestbedSetting("My Range Setting", SettingType.ENGINE, 10, 0, 20));

TestbedPanel panel = new TestPanelJ2D(model);    // create our testbed panel

JFrame testbed = new TestbedFrame(model, panel); // put both into our testbed frame
// etc
testbed.setVisible(true);
testbed.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
}}}

Tests and settings are covered more in-depth later, but that should give you a pretty good idea how to set up your own testbed.

= A Simple Test =

Our friend 'MJW' wrote this test during the re-write to 2.1.2 to highlight a strange bug with corner collisions of polygons:

{{{
public class MJWTest extends TestbedTest {

  @Override
  public void initTest(boolean argDeserialized) {
    setTitle("Couple of Things Test");

    getWorld().setGravity(new Vec2());

    for (int i = 0; i < 2; i++) {
      PolygonShape polygonShape = new PolygonShape();
      polygonShape.setAsBox(1, 1);
      
      BodyDef bodyDef = new BodyDef();
      bodyDef.type = BodyType.DYNAMIC;
      bodyDef.position.set(5 * i, 0);
      bodyDef.angle = (float) (Math.PI / 4 * i);
      bodyDef.allowSleep = false;
      Body body = getWorld().createBody(bodyDef);
      body.createFixture(polygonShape, 5.0f);

      body.applyForce(new Vec2(-10000 * (i - 1), 0), new Vec2());
    }
  }

  @Override
  public String getTestName() {
    return "Couple of Things";
  }
}
}}}

The only required methods for a test are `getTestName`, which should return the test name, and 'initTest' for test initialization.  We'll go over the deserialized argument later.

= Handling Input =

The testbed provides both storage of the mouse + keyboard state and hook methods for state changes.

== Input State ==
The current input state is stored in the `TestbedModel` and in your superclass `TestbedTest`.  Here is an example of grabbing this:

{{{
// let's say we're in a custom test
@Override
public void step(TestbedSettings settings) {
  super.step(settings);
  
  TestbedModel model = getModel();
  if (model.getKeys()['a']) { // model also contains the coded key values
    applyLeftForce();
  }

  Vec2 screenMouse = model.getMouse();
  // ^^ this is in screen coordinates, so we'd rather grab:
  Vec2 worldMouse = super.getWorldMouse(); // which is in world coordinates

  // etc
}
}}}

== Hooks ==
The testbed also provides overridable hooks for input (and the world) as well.  Here are they are:
{{{
// engine hooks
void jointDestroyed(Joint joint);
void beginContact(Contact contact);
void endContact(Contact contact);
void postSolve(Contact contact, ContactImpulse impulse);
void preSolve(Contact contact, Manifold oldManifold);
// mouse hooks
void shiftMouseDown(Vec2 p);
void mouseUp(Vec2 p);
void mouseDown(Vec2 p);
void mouseMove(Vec2 p);
// key hooks
void keyPressed(char argKeyChar, int argKeyCode);
void keyReleased(char argKeyChar, int argKeyCode);
}}}

Keep in mind that the hook methods might also be used by the `TestbedTest` class, so make sure to call `super.method()` as well.

= Serialization (Saving/Loading) =

= Custom Real-Time Settings =

= Putting it all together =